# FreeBSD Kernel Exploit Mitigations as of FreeBSD 14.3

| Mitigation                           | Default Status                                                   | Tunable(s) / How to Check |
|--------------------------------------|------------------------------------------------------------------|----------------------------|
| **Kernel ASLR (KASLR)**              | Off by default (experimental)                                    | `kern.elf64.aslr.*` loader tunables (`/boot/loader.conf`) |
| **Kernel Stack Canaries (SSP)**      | On by default (since 8.0, compile-time)                          | None (built into kernel build with `-fstack-protector`) |
| **Kernel Heap-Smash Detection**      | On by default (since 8.0)                                        | `sysctl debug.redzone` / `sysctl debug.chunk` |
| **Null Pointer Protection**          | On by default (`security.bsd.map_at_zero=0`)                     | `sysctl security.bsd.map_at_zero` |
| **W^X (Write XOR Execute)**          | On by default                                                    | None (VM subsystem enforces) |
| **SMEP (Supervisor Mode Exec Prevent)** | On by default if CPU supports                                   | `dmesg \| grep SMEP` |
| **SMAP (Supervisor Mode Access Prevent)** | On by default if CPU supports                                  | `dmesg \| grep SMAP` |
| **Speculative Execution Mitigations** (Spectre, Meltdown, MDS, L1TF, etc.) | On by default if CPU affected & microcode present               | `sysctl hw.mds_disable hw.ibrs_disable hw.spec_store_bypass_disable hw.l1tf_disable hw.fsgsbase_mode` |
| **Securelevel**                      | Off by default (`kern.securelevel=0`)                            | `sysctl kern.securelevel` |
| **Capsicum (kernel enforcement infra)** | Off by default, available only if a process opts in             | `procstat -s <pid>` (per-process capability mode) |

The bottom 3 aren't very relevant. For our purposes, the following are things we'll have to consider:
- Kernel Stack Canaries (can be defeated with an info leak)
- Kernel Heap-smash detection (red zone and chunk guards, red zones are fixed patterns. The chunk guard is a random value and can be defeated with an info leak.)
- W^X (will need to ROP or do data-only attacks)
- SMEP/SMAP (We don't get to jump to userland, doesn't apply to i386, ...)

---

# Tunables and Sysctls

### Kernel ASLR (KASLR)
```
kern.elf64.aslr.enable=1
kern.elf64.aslr.pie_enable=1
kern.elf64.aslr.stack=1
kern.elf64.aslr.vdso=1
kern.elf64.aslr.honor_sbrk=0
```
*(loader.conf tunables, mostly userland â€” kernel ASLR support exists but is disabled by default)*

### Kernel Heap-Smash Detection
```
debug.redzone
debug.chunk
```

### Null Pointer Protection
```
security.bsd.map_at_zero
```

### Speculative Execution Mitigations
```
hw.mds_disable
hw.ibrs_disable
hw.spec_store_bypass_disable
hw.l1tf_disable
hw.fsgsbase_mode
```

### Securelevel
```
kern.securelevel
```

### SMEP / SMAP
No sysctl. Check boot messages:
```
dmesg | grep -E "SMEP|SMAP"
```

### W^X
No sysctl. Enforced by VM subsystem for kernel text/data mappings.

### Stack Canaries
No sysctl. Enabled at kernel build time (`-fstack-protector-strong`).

### Capsicum
No global sysctl. Per-process, check with:
```
procstat -s <pid>
```
